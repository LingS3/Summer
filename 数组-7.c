/*链接：https://www.nowcoder.com/questionTerminal/325483e19dab4609baf00157e5ebeb6f
来源：牛客网

输入一个无序整数数组，调整数组中数字的顺序， 所有偶数位于数组的前半部分，使得所有奇数位于数组的后半部分。
要求时间复杂度为O(n)。

输入描述:
给定无序数组。
长度不超过1000000。


输出描述:
所有偶数位于数组的前半部分，所有奇数位于数组的后半部分。
如果有多个答案可以输出任意一个正确答案。
示例1
输入
2 4 5 7 8 1
输出
2 4 8 7 5 1
*/

//解题思路：
/*要有一个辅助数组b[n];
首先，判断奇偶，是偶数则++,留再原数组中，从0重新开始;是奇数就放到辅助数组中
最后，把辅助数组中的数放到原数组的后半部分就可以了、
//因为不用按特定顺序从小到大或从大到小的输出，所以可以直接输出,
如果要用排序的话极有可能会超时，因为循环比较耗时
如果要求奇数和偶数按顺序的话可以先对原数组进行排序，再判断奇偶性
*/
#include<stdio.h>
#include<malloc.h>
int main(void)
{
    int *a=(int *)malloc(1000000*sizeof(int));
    int *b=(int *)malloc(1000000*sizeof(int));//int a[1000000],b[1000000]栈内存和堆内存
    int i=0,j=0,k=0,l=0,n;
    printf("请输入数组中的数字，用空格隔开，回车键结尾：");
    do
    {
        scanf("%d",&a[i]);
        i++;
    } while (getchar()!='\n');
    n=i;
    for(j=0;j<n;j++)
    {
        if(a[j]%2==0)
        {
            a[k]=a[j];
            k++;
        }
        else
        {
            b[l]=0;
            b[l]=a[j];
            l++;
        }  
    }  
    for(j=0;j<l;j++)
    {
        a[k]=b[j];
        k++;
    }
    for(j=0;j<k;j++)
    {
        printf("%d ",a[j]);
    }
    free(a);
    free(b);
    return 0;
}

//写在最后的话
/*int n[1000000];
这样肯定是不行的，因为这样定义的数组用的是栈内存，
系统默认值为最大1Mb，一个int型占4字节这样最大可以申请1024*1024/4=264144个，
如果考虑到系统自身的占用最大值约为25000个。所以直接用int类型是不可以的
int *p=(int *)malloc(1000000*sizeof(int));
这样用的是堆内存，只要你内存有那么多的连续空间就可以*/