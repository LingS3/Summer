/*题目描述
扫雷游戏是一款十分经典的单机小游戏。它的精髓在于，通过已翻开格子所提示的周围格地雷数，来判断未翻开格子里是否是地雷。
现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格的周围格地雷数。
注：每个格子周围格有八个：上、下、左、右、左上、右上、左下、右下。

输入
第一行包含两个整数n和m，分别表示雷区的行数和列数。1 <= n <= 100, 1 <= m <= 100。
接下来n行，每行m个字符，‘*’表示相应格子中是地雷，‘？’表示相应格子中无地雷。字符之间无任何分隔符。

输出
n行，每行m个字符，描述整个雷区。若相应格中是地雷，则用‘*’表示，否则用相应的周围格地雷数表示。字符之间无任何分隔符。

样例输入
3 3
*??
???
?*?

样例输出
*10
221
1*1

数据范围限制
1 <= n <= 100, 1 <= m <= 100。*/

//解题思路：
/*初步想法，利用循环和判断，
1.循环是遍历整个雷区，
2.判断是先判断该格子中是否是地雷，是地雷的话就下一个格子
3.不是地雷的话，就判断该格子周围八个格子中是否有地雷，有的话就+1，
关键点在于如何表示雷区周围的格子*/

#include<iostream> 
using namespace std;
int main() 
{ 
    int n,m,count=0; 
    cin>>n>>m; 
    char a[n+1][m+1]; 
    //int b[n+1][m+1]; 
    for(int i=0;i<n;i++)//输入 
        for(int j=0;j<m;j++) 
            cin>>a[i][j]; 
    for(int i=0;i<n;i++) 
     { 
         for(int j=0;j<m;j++) 
        { 
            if(a[i][j]=='*')//进行判断
            cout<<a[i][j];//直接输出，缩短运行时间，避免输出浪费时间
            else //判断非雷的格子的周围八个格子中有没有雷
            { 
                if(a[i-1][j]=='*') //上
                count++; 
                if(a[i+1][j]=='*') //下
                count++; 
                if(a[i][j-1]=='*') //左
                count++; 
                if(a[i][j+1]=='*') //右
                count++; 
                if(a[i-1][j-1]=='*')//左上 
                count++; 
                if(a[i+1][j-1]=='*') //左下
                count++; 
                if(a[i-1][j+1]=='*') //右上
                count++; 
                if(a[i+1][j+1]=='*') //右下
                count++;  
                cout<<count; 
            } 
             count=0; //把循环计数的count归0
         } 
         printf("\n"); 
    } 
    return 0; 
 } 

